"""Utility helpers for streaming encryption.

The previous implementation relied on AES-CTR.  This module has been
updated to use AES-GCM for authenticated encryption.  Each encrypted
payload requires a fresh 96-bit nonce and produces a 16-byte
authentication tag.  Both values must be stored alongside the
ciphertext to allow successful decryption.

Functions here operate on iterables of bytes objects so large files can
be processed without buffering the entire payload in memory.
"""

from typing import Iterable, Iterator, Tuple

import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.keywrap import (
    aes_key_wrap,
    aes_key_unwrap,
)


def generate_file_key() -> bytes:
    """Generate a new 256-bit symmetric key for file encryption."""
    return os.urandom(32)


def encrypt_stream(key: bytes, nonce: bytes, stream: Iterable[bytes]) -> Tuple[Iterator[bytes], bytes]:
    """Encrypt an iterator of bytes using AES-GCM.

    Parameters
    ----------
    key: bytes
        Symmetric key generated by :func:`generate_file_key`.
    nonce: bytes
        Unique 12-byte nonce for this encryption operation.
    stream: Iterable[bytes]
        Iterator yielding plaintext chunks.

    Returns
    -------
    (Iterator[bytes], bytes)
        Tuple of encrypted chunks iterator and the authentication tag.
    """
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce))
    encryptor = cipher.encryptor()

    chunks = []
    for chunk in stream:
        chunks.append(encryptor.update(chunk))
    tail = encryptor.finalize()
    if tail:
        chunks.append(tail)
    tag = encryptor.tag
    return iter(chunks), tag


def decrypt_stream(key: bytes, nonce: bytes, tag: bytes, stream: Iterable[bytes]) -> Iterator[bytes]:
    """Decrypt an iterator of bytes previously encrypted with :func:`encrypt_stream`.

    Parameters
    ----------
    key: bytes
        Symmetric key generated by :func:`generate_file_key`.
    nonce: bytes
        12-byte nonce used during encryption.
    tag: bytes
        Authentication tag produced during encryption.
    stream: Iterable[bytes]
        Iterator yielding encrypted chunks.

    Yields
    ------
    bytes
        Decrypted plaintext chunks.
    """
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag))
    decryptor = cipher.decryptor()
    for chunk in stream:
        yield decryptor.update(chunk)
    tail = decryptor.finalize()
    if tail:
        yield tail


def wrap_file_key(file_key: bytes, link_key: bytes) -> bytes:
    """Wrap ``file_key`` using ``link_key`` with RFC 3394 AES Key Wrap."""
    return aes_key_wrap(link_key, file_key)


def unwrap_file_key(wrapped: bytes, link_key: bytes) -> bytes:
    """Unwrap ``file_key`` using ``link_key`` and RFC 3394 AES Key Wrap."""
    return aes_key_unwrap(link_key, wrapped)
