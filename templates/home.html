{% extends "base.html" %}

{% block content %}
<div class="container">
    <h1>Upload Files</h1>
    <div id="messageContainer" class="message-container" style="display: none; padding: 10px; margin-bottom: 15px; border-radius: 5px; text-align: center; font-weight: bold;"></div>
    <form id="uploadForm" action="/upload_file" method="post" enctype="multipart/form-data">
        <div class="form-group">
            <label for="file">Select File:</label>
            <input type="file" id="file" name="file" required>
        </div>
        <button type="submit">Upload</button>
    </form>

    <div id="progressBarContainer" style="display: none; margin-top: 20px;">
        <div id="progressBar">
            <span id="progressText" style="font-weight: bold;"></span>
        </div>
    </div>
    <p id="progressStatus" style="text-align: center; margin-top: 10px; font-weight: bold; color: #bb86fc;"></p>
    <p id="progressSubText" style="text-align: center; font-size: 0.9em; color: #b0b0b0;"></p>


    <h2 style="margin-top: 40px;">Your Files</h2>
    <div id="files-container">
        <!-- Files will be loaded here via JavaScript or directly from Flask context -->
        {% if files %}
            <table class="table">
                <thead>
                    <tr>
                        <th>Filename</th>
                        <th>Size</th>
                        <th>Public Link</th>
                        <th>Public Access</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {% for file in files %}
                        <tr data-file-id="{{ file.id }}" data-file-hash="{{ file.file_hash }}">
                            <td>{{ file.name }}</td>
                            <td class="filesize-cell">{{ file.size | format_bytes }}</td>
                            <td>
                                {% if file.file_hash %}
                                    <a href="{{ url_for('download_by_hash', salted_sha512_hash=file.file_hash) }}" target="_blank" class="public-link">
                                        {{ request.url_root }}d/{{ file.file_hash[:10] }}...
                                    </a>
                                {% else %}
                                    N/A
                                {% endif %}
                            </td>
                            <td>
                                <label class="switch">
                                    <input type="checkbox" class="public-toggle" {% if file.is_public %}checked{% endif %}>
                                    <span class="slider round"></span>
                                </label>
                            </td>
                            <td>
                                <a href="{{ url_for('download_by_hash', salted_sha512_hash=file.file_hash) }}" class="btn btn-primary">Download</a>
                                <button class="btn btn-danger delete-btn" data-file-id="{{ file.id }}">Delete</button>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No files found.</p>
        {% endif %}
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
<script>
    const socket = io();

    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function updateProgress(data) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressSubText = document.getElementById('progressSubText');
        const progressStatus = document.getElementById('progressStatus');
        console.log('Progress Event:', data);

        const percentage = data.percentage || 0;

        // Directly update the progress bar. No more smoothing.
        progressBar.style.width = percentage + '%';
        progressText.textContent = `${Math.round(percentage)}%`;
        
        // Update status message based on explicit status or percentage
        if (data.status) {
            // Use the explicit status from the server (e.g., "Finalizing...")
            progressStatus.textContent = data.status;
        } else if (percentage < 100) {
            progressStatus.textContent = 'Uploading...';
        }
        // The 'Upload complete!' status is handled by the 'upload_complete' event handler.

        // Update the bytes transferred
        if (data.bytes_uploaded !== undefined && data.total_bytes !== undefined) {
            const uploadedFormatted = formatBytes(data.bytes_uploaded);
            const totalFormatted = formatBytes(data.total_bytes);
            let statusText = `${uploadedFormatted} / ${totalFormatted}`;
            // The part text is now less important as percentage is the source of truth
            if (data.part && data.total_parts && percentage < 100) {
                 statusText += ` (Part ${data.part} of ${data.total_parts})`;
            }
            progressSubText.textContent = statusText;
        } else {
            progressSubText.textContent = '';
        }
    }

    socket.on('upload_progress', updateProgress);

    socket.on('upload_complete', function(data) {
        console.log("Upload Complete Data:", data);
        if (data.status === 'success') {
            // Show final completion state
            updateProgress({
                percentage: 100,
                status: 'Upload complete!',
                bytes_uploaded: data.total_bytes,
                total_bytes: data.total_bytes
            });
            
            // Hide progress after a delay and reload to show the new file
            setTimeout(() => {
                const progressBarContainer = document.getElementById('progressBarContainer');
                const progressStatus = document.getElementById('progressStatus');
                const progressSubText = document.getElementById('progressSubText');
                
                progressBarContainer.style.display = 'none';
                progressStatus.style.display = 'none';
                progressSubText.textContent = '';
                
                window.location.reload();
            }, 1000);
        } else {
            // Handle error
            const progressStatus = document.getElementById('progressStatus');
            progressStatus.textContent = data.error || 'Upload failed';
            progressStatus.style.color = '#ff6b6b';
        }
    });

    document.getElementById('uploadForm').addEventListener('submit', async function(event) {
        event.preventDefault(); // Prevent default form submission

        const form = event.target;
        const formData = new FormData(form);

        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressSubText = document.getElementById('progressSubText');

        progressBarContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressText.textContent = '0%';
        progressSubText.textContent = '';

        try {
            const url = form.action;
            const options = {
                method: form.method,
                body: formData
            };
            console.log('Fetch Request Initiated:');
            console.log('  URL:', url);
            console.log('  Method:', options.method);
            // Note: formData content cannot be easily logged directly here as it's a stream.
            // console.log('  Body:', options.body); // This would consume the stream.

            const response = await fetch(url, options);
            console.log('Fetch Response Received:');
            console.log('  Raw Response Object:', response);
            console.log('  Response Status:', response.status);
            console.log('  Response OK:', response.ok);

            if (!response.ok) {
                let errorMessage = 'Upload failed';
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                } catch (jsonError) {
                    // If response is not JSON, use status text
                    errorMessage = `Server error: ${response.status} ${response.statusText}`;
                }
                throw new Error(errorMessage);
            }

            const responseData = await response.json(); // Assuming server always returns JSON on success
            console.log('Parsed JSON Response Data:', responseData);

            // Add a small delay before redirection
            console.log('Initiating redirection setTimeout for 1000ms...');
            setTimeout(() => {
                console.log('Redirecting to home page...');
                window.location.href = '/';
            }, 1000); // 1000ms delay

        } catch (error) {
            console.error('Upload Error Caught:');
            console.error('  Error Object:', error);
            console.error('  Error Name:', error.name);
            console.error('  Error Message:', error.message);
            if (error.stack) {
                console.error('  Error Stack:', error.stack);
            }
            let displayMessage = 'Upload failed';
            if (error.message.includes('NetworkError')) {
                displayMessage = 'Upload failed: Network error. Please check your internet connection.';
            } else {
                displayMessage = 'Upload failed: ' + error.message;
            }
            alert(displayMessage);
            progressBarContainer.style.display = 'none';
        }
    });

    document.querySelectorAll('.delete-btn').forEach(button => {
        button.addEventListener('click', async function(event) {
            const fileId = this.dataset.fileId;
            const fileHash = this.closest('tr').dataset.fileHash; // Get file hash from the row
            if (!confirm('Are you sure you want to delete this file?')) {
                return;
            }

            console.log('Attempting to delete file with ID:', fileId, 'and Hash:', fileHash);
            try {
                const response = await fetch('/delete_file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ file_id: fileId, file_hash: fileHash }) // Include file_hash
                });
                console.log('Delete request sent. Response:', response);

                if (!response.ok) {
                    let errorMessage = 'Failed to delete file';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (jsonError) {
                        errorMessage = `Server error: ${response.status} ${response.statusText}`;
                    }
                    throw new Error(errorMessage);
                }

                const responseData = await response.json();
                if (responseData.status === 'success') {
                    // Remove the row from the table
                    this.closest('tr').remove();
                    const messageContainer = document.getElementById('messageContainer');
                    messageContainer.textContent = 'File deleted successfully!';
                    messageContainer.style.backgroundColor = '#d4edda'; /* Light green */
                    messageContainer.style.color = '#155724'; /* Dark green */
                    messageContainer.style.display = 'block';

                    setTimeout(() => {
                        messageContainer.style.display = 'none';
                        messageContainer.textContent = '';
                    }, 7000); // Hide after 7 seconds
                } else {
                    const messageContainer = document.getElementById('messageContainer');
                    messageContainer.textContent = responseData.error || 'Failed to delete file.';
                    messageContainer.style.backgroundColor = '#f8d7da'; /* Light red */
                    messageContainer.style.color = '#721c24'; /* Dark red */
                    messageContainer.style.display = 'block';

                    setTimeout(() => {
                        messageContainer.style.display = 'none';
                        messageContainer.textContent = '';
                    }, 7000); // Hide after 7 seconds
                }

            } catch (error) {
                console.error('Delete Error:', error);
                const messageContainer = document.getElementById('messageContainer');
                messageContainer.textContent = 'Error deleting file: ' + error.message;
                messageContainer.style.backgroundColor = '#f8d7da'; /* Light red */
                messageContainer.style.color = '#721c24'; /* Dark red */
                messageContainer.style.display = 'block';

                setTimeout(() => {
                    messageContainer.style.display = 'none';
                    messageContainer.textContent = '';
                }, 7000); // Hide after 7 seconds
            }
        });
    });
</script>

<style>
/* Basic Switch Styles */
.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
  border-radius: 20px; /* Make it round */
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
  border-radius: 50%; /* Make it round */
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(20px);
  -ms-transform: translateX(20px);
  transform: translateX(20px);
}

/* Add smooth transition to progress bar */
#progressBar {
    transition: width 0.3s ease-out;
}

/* Add transition to status message color changes */
#progressStatus {
    transition: color 0.3s ease;
}
</style>

<script>
    document.querySelectorAll('.public-toggle').forEach(toggle => {
        toggle.addEventListener('change', async function() {
            const row = this.closest('tr');
            const fileId = row.dataset.fileId;
            const fileHash = row.dataset.fileHash;
            const isPublic = this.checked;

            console.log(`Toggling public access for file ID: ${fileId}, Hash: ${fileHash}, New status: ${isPublic}`);

            try {
                const response = await fetch('/toggle_public_access', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        file_id: fileId,
                        is_public: isPublic,
                        salted_sha512_hash: fileHash
                    })
                });

                if (!response.ok) {
                    let errorMessage = 'Failed to update public status';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (jsonError) {
                        errorMessage = `Server error: ${response.status} ${response.statusText}`;
                    }
                    throw new Error(errorMessage);
                }

                const responseData = await response.json();
                if (responseData.status === 'success') {
                    const messageContainer = document.getElementById('messageContainer');
                    messageContainer.textContent = `File public status updated to ${isPublic ? 'public' : 'private'}!`;
                    messageContainer.style.backgroundColor = '#d4edda';
                    messageContainer.style.color = '#155724';
                    messageContainer.style.display = 'block';

                    setTimeout(() => {
                        messageContainer.style.display = 'none';
                        messageContainer.textContent = '';
                    }, 5000);
                } else {
                    // Revert toggle if update failed
                    this.checked = !isPublic;
                    const messageContainer = document.getElementById('messageContainer');
                    messageContainer.textContent = responseData.error || 'Failed to update public status.';
                    messageContainer.style.backgroundColor = '#f8d7da';
                    messageContainer.style.color = '#721c24';
                    messageContainer.style.display = 'block';

                    setTimeout(() => {
                        messageContainer.style.display = 'none';
                        messageContainer.textContent = '';
                    }, 7000);
                }

            } catch (error) {
                console.error('Toggle Public Access Error:', error);
                this.checked = !isPublic; // Revert toggle on network/client error
                const messageContainer = document.getElementById('messageContainer');
                messageContainer.textContent = 'Error updating public status: ' + error.message;
                messageContainer.style.backgroundColor = '#f8d7da';
                messageContainer.style.color = '#721c24';
                messageContainer.style.display = 'block';

                setTimeout(() => {
                    messageContainer.style.display = 'none';
                    messageContainer.textContent = '';
                }, 7000);
            }
        });
    });
</script>
{% endblock %}