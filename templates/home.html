{% extends "base.html" %}

{% block content %}
<div class="container">
    <h1>Upload Files</h1>
    <div id="messageContainer" class="message-container" style="display: none; padding: 10px; margin-bottom: 15px; border-radius: 5px; text-align: center; font-weight: bold;"></div>
    <form id="uploadForm" action="/upload_file" method="post" enctype="multipart/form-data">
        <div class="form-group">
            <label for="file">Select File:</label>
            <input type="file" id="file" name="file" required>
        </div>
        <button type="submit">Upload</button>
    </form>

    <div id="progressBarContainer" style="display: none; margin-top: 20px;">
        <div id="progressBar">
            <span id="progressText" style="font-weight: bold;"></span>
        </div>
    </div>
    <p id="progressSubText" style="text-align: center; font-size: 0.9em; color: #b0b0b0;"></p>


    <h2 style="margin-top: 40px;">Your Files</h2>
    <div id="files-container">
        <!-- Files will be loaded here via JavaScript or directly from Flask context -->
        {% if files %}
            <table class="table">
                <thead>
                    <tr>
                        <th>Filename</th>
                        <th>Size</th>
                        <th>Public Link</th>
                        <th>Public Access</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {% for file in files %}
                        <tr data-file-id="{{ file.id }}" data-file-hash="{{ file.file_hash }}">
                            <td>{{ file.name }}</td>
                            <td class="filesize-cell">{{ file.size | format_bytes }}</td>
                            <td>
                                {% if file.file_hash %}
                                    <a href="{{ url_for('download_by_hash', salted_sha512_hash=file.file_hash) }}" target="_blank" class="public-link">
                                        {{ request.url_root }}d/{{ file.file_hash[:10] }}...
                                    </a>
                                {% else %}
                                    N/A
                                {% endif %}
                            </td>
                            <td>
                                <label class="switch">
                                    <input type="checkbox" class="public-toggle" {% if file.is_public %}checked{% endif %}>
                                    <span class="slider round"></span>
                                </label>
                            </td>
                            <td>
                                <a href="{{ url_for('download_by_hash', salted_sha512_hash=file.file_hash) }}" class="btn btn-primary">Download</a>
                                <button class="btn btn-danger delete-btn" data-file-id="{{ file.id }}">Delete</button>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No files found.</p>
        {% endif %}
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
<script>
    const socket = io({
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    timeout: 20000,
    autoConnect: true
});

    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    socket.on('upload_progress', function(data) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressSubText = document.getElementById('progressSubText');
        console.log('Upload Progress Data (Notion):', data); 

        if (data.percentage !== undefined) {
            progressBar.style.width = data.percentage + '%';
            progressText.textContent = `${data.percentage.toFixed(2)}%`;

            if (data.bytes_uploaded !== undefined && data.total_bytes !== undefined) {
                const uploadedMB = (data.bytes_uploaded / (1024 * 1024)).toFixed(2);
                const totalMB = (data.total_bytes / (1024 * 1024)).toFixed(2);
                progressSubText.textContent = `Uploading to Notion: ${uploadedMB} MB / ${totalMB} MB`;
            } else {
                progressSubText.textContent = 'Uploading to Notion...';
            }
        }
    });

    // Function to fetch file list and update the UI
    function refreshFileList() {
        console.log('Refreshing file list via AJAX...');
        fetch('/files-api')
            .then(response => response.json())
            .then(data => {
                console.log('Files data received:', data);
                if (data.files) {
                    updateFilesTable(data.files);
                    console.log('File list updated successfully!');
                }
            })
            .catch(error => {
                console.error('Error fetching file list:', error);
            });
    }

    // Function to update the files table in the DOM
    function updateFilesTable(files) {
        const filesContainer = document.getElementById('files-container');
        
        if (files.length === 0) {
            filesContainer.innerHTML = '<p>No files found.</p>';
            return;
        }
        
        let tableHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Filename</th>
                        <th>Size</th>
                        <th>Public Link</th>
                        <th>Public Access</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        files.forEach(file => {
            const fileSize = formatBytes(file.size);
            const hashPreview = file.file_hash ? file.file_hash.substring(0, 10) + '...' : '';
            
            tableHTML += `
                <tr data-file-id="${file.id}" data-file-hash="${file.file_hash}">
                    <td>${file.name}</td>
                    <td class="filesize-cell">${fileSize}</td>
                    <td>
                        ${file.file_hash ? 
                            `<a href="/d/${file.file_hash}" target="_blank" class="public-link">
                                ${window.location.origin}/d/${hashPreview}
                            </a>` : 
                            'N/A'
                        }
                    </td>
                    <td>
                        <label class="switch">
                            <input type="checkbox" class="public-toggle" ${file.is_public ? 'checked' : ''}>
                            <span class="slider round"></span>
                        </label>
                    </td>
                    <td>
                        <a href="/d/${file.file_hash}" class="btn btn-primary">Download</a>
                        <button class="btn btn-danger delete-btn" data-file-id="${file.id}">Delete</button>
                    </td>
                </tr>
            `;
        });
        
        tableHTML += `
                </tbody>
            </table>
        `;
        
        filesContainer.innerHTML = tableHTML;
        
        // Reattach event listeners for delete buttons
        document.querySelectorAll('.delete-btn').forEach(button => {
            button.addEventListener('click', handleDeleteButtonClick);
        });
        
        // Reattach event listeners for public toggles
        document.querySelectorAll('.public-toggle').forEach(toggle => {
            toggle.addEventListener('change', handlePublicToggleChange);
        });
    }
    
    socket.on('upload_complete', function(data) {
        console.log('Socket: Upload complete event received:', data);
        const progressBarContainer = document.getElementById('progressBarContainer');
        
        // Clear the failsafe timer if it exists
        if (window.uploadCompleteTimer) {
            console.log('Clearing failsafe timer');
            clearTimeout(window.uploadCompleteTimer);
            window.uploadCompleteTimer = null;
        }
        
        if (data.status === 'error') {
            progressBarContainer.style.display = 'none';
            alert(data.error || 'Upload failed'); // Handle error
        } else {
            // Show 100% complete
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressSubText = document.getElementById('progressSubText');
            
            progressBar.style.width = '100%';
            progressText.textContent = '100%';
            progressSubText.textContent = 'Upload complete! Updating file list...';
            
            // Refresh the file list without reloading the page
            refreshFileList();
            
            // Hide the progress bar after a short delay
            setTimeout(function() {
                progressBarContainer.style.display = 'none';
            }, 1500);
        }
    });
    
    // Backup reload mechanism in case the socket event doesn't trigger
    socket.on('connect', function() {
        console.log('Socket connected:', socket.connected);
    });
    
    socket.on('disconnect', function() {
        console.log('Socket disconnected');
    });


    document.getElementById('uploadForm').addEventListener('submit', function(event) {
        event.preventDefault(); // Prevent default form submission

        const form = event.target;
        const formData = new FormData(form);
        const url = form.action;

        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressSubText = document.getElementById('progressSubText');

        progressBarContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressText.textContent = '0%';
        progressSubText.textContent = 'Uploading to server...';

        // Use XMLHttpRequest for upload progress tracking
        const xhr = new XMLHttpRequest();
        
        // Track client-to-server upload progress
        xhr.upload.onprogress = function(event) {
            if (event.lengthComputable) {
                const percentComplete = (event.loaded / event.total) * 100;
                progressBar.style.width = percentComplete + '%';
                progressText.textContent = percentComplete.toFixed(2) + '%';
                const uploadedMB = (event.loaded / (1024 * 1024)).toFixed(2);
                const totalMB = (event.total / (1024 * 1024)).toFixed(2);
                progressSubText.textContent = `Uploading to server: ${uploadedMB} MB / ${totalMB} MB`;
                
                console.log('Client-to-server progress:', percentComplete.toFixed(2) + '%');
            }
        };

        // Setup completion handler
        xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
                console.log('Upload to server complete. Status:', xhr.status);
                progressSubText.textContent = 'Upload to server complete. Transferring to Notion...';
                
                try {
                    const responseData = JSON.parse(xhr.responseText);
                    console.log('Parsed JSON Response Data:', responseData);
                    
                    // Set a quicker failsafe timer - try to refresh the file list in 8 seconds
                    // This is a good balance between waiting for Socket.IO events and providing quick feedback
                    console.log('Setting failsafe file list refresh timer for 8 seconds');
                    window.uploadCompleteTimer = setTimeout(function() {
                        console.log('Failsafe timer triggered - refreshing file list');
                        progressBar.style.width = '100%';
                        progressText.textContent = '100%';
                        progressSubText.textContent = 'Upload complete! Updating file list...';
                        
                        // Refresh files and hide progress bar
                        refreshFileList();
                        setTimeout(function() {
                            progressBarContainer.style.display = 'none';
                        }, 1500);
                    }, 8000);
                } catch (error) {
                    console.error('Error parsing response:', error);
                }
            } else {
                let errorMessage = 'Upload failed';
                try {
                    const errorData = JSON.parse(xhr.responseText);
                    errorMessage = errorData.error || errorMessage;
                } catch (jsonError) {
                    errorMessage = `Server error: ${xhr.status} ${xhr.statusText}`;
                }
                console.error('Upload Error:', errorMessage);
                alert(errorMessage);
                progressBarContainer.style.display = 'none';
            }
        };

        // Error handler
        xhr.onerror = function() {
            console.error('Network Error during upload');
            alert('Upload failed: Network error. Please check your internet connection.');
            progressBarContainer.style.display = 'none';
        };

        // Setup and send the request
        xhr.open(form.method, url, true);
        console.log('XMLHttpRequest initialized:');
        console.log('  URL:', url);
        console.log('  Method:', form.method);
        xhr.send(formData);
    });

    // Function to handle delete button clicks
    async function handleDeleteButtonClick(event) {
        const fileId = this.dataset.fileId;
        const fileHash = this.closest('tr').dataset.fileHash; // Get file hash from the row
        if (!confirm('Are you sure you want to delete this file?')) {
            return;
        }

        console.log('Attempting to delete file with ID:', fileId, 'and Hash:', fileHash);
        try {
            const response = await fetch('/delete_file', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ file_id: fileId, file_hash: fileHash }) // Include file_hash
            });
            console.log('Delete request sent. Response:', response);

            if (!response.ok) {
                let errorMessage = 'Failed to delete file';
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                } catch (jsonError) {
                    errorMessage = `Server error: ${response.status} ${response.statusText}`;
                }
                throw new Error(errorMessage);
            }

            const responseData = await response.json();
            if (responseData.status === 'success') {
                // Remove the row from the table
                this.closest('tr').remove();
                const messageContainer = document.getElementById('messageContainer');
                messageContainer.textContent = 'File deleted successfully!';
                messageContainer.style.backgroundColor = '#d4edda'; /* Light green */
                messageContainer.style.color = '#155724'; /* Dark green */
                messageContainer.style.display = 'block';

                setTimeout(() => {
                    messageContainer.style.display = 'none';
                    messageContainer.textContent = '';
                }, 7000); // Hide after 7 seconds
            } else {
                showMessage(responseData.error || 'Failed to delete file.', 'error');
            }

        } catch (error) {
            console.error('Delete Error:', error);
            showMessage('Error deleting file: ' + error.message, 'error');
        }
    }

    // Helper function to show messages
    function showMessage(message, type = 'success') {
        const messageContainer = document.getElementById('messageContainer');
        messageContainer.textContent = message;
        
        if (type === 'error') {
            messageContainer.style.backgroundColor = '#f8d7da'; /* Light red */
            messageContainer.style.color = '#721c24'; /* Dark red */
        } else {
            messageContainer.style.backgroundColor = '#d4edda'; /* Light green */
            messageContainer.style.color = '#155724'; /* Dark green */
        }
        
        messageContainer.style.display = 'block';

        setTimeout(() => {
            messageContainer.style.display = 'none';
            messageContainer.textContent = '';
        }, 7000); // Hide after 7 seconds
    }

    // Attach delete event listeners
    document.querySelectorAll('.delete-btn').forEach(button => {
        button.addEventListener('click', handleDeleteButtonClick);
    });
</script>

<style>
/* Basic Switch Styles */
.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
  border-radius: 20px; /* Make it round */
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
  border-radius: 50%; /* Make it round */
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(20px);
  -ms-transform: translateX(20px);
  transform: translateX(20px);
}
</style>

<script>
    // Function to handle public toggle changes
    async function handlePublicToggleChange() {
        const row = this.closest('tr');
        const fileId = row.dataset.fileId;
        const fileHash = row.dataset.fileHash;
        const isPublic = this.checked;

        console.log(`Toggling public access for file ID: ${fileId}, Hash: ${fileHash}, New status: ${isPublic}`);

        try {
            const response = await fetch('/toggle_public_access', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    file_id: fileId,
                    is_public: isPublic,
                    salted_sha512_hash: fileHash
                })
            });

            if (!response.ok) {
                let errorMessage = 'Failed to update public status';
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                } catch (jsonError) {
                    errorMessage = `Server error: ${response.status} ${response.statusText}`;
                }
                throw new Error(errorMessage);
            }

            const responseData = await response.json();
            if (responseData.status === 'success') {
                showMessage(`File public status updated to ${isPublic ? 'public' : 'private'}!`);
            } else {
                // Revert toggle if update failed
                this.checked = !isPublic;
                showMessage(responseData.error || 'Failed to update public status.', 'error');
            }

        } catch (error) {
            console.error('Toggle Public Access Error:', error);
            this.checked = !isPublic; // Revert toggle on network/client error
            showMessage('Error updating public status: ' + error.message, 'error');
        }
    }

    // Attach public toggle event listeners
    document.querySelectorAll('.public-toggle').forEach(toggle => {
        toggle.addEventListener('change', handlePublicToggleChange);
    });
</script>
{% endblock %}